---
title: "Proposition for an updated concatipede workflow"
date: "`r Sys.Date()`"
vignette: >
  %\VignetteIndexEntry{Proposition for an updated concatipede workflow}
  %\VignetteEngine{knitr::rmarkdown}
  \usepackage[utf8]{inputenc}
---

```{r include = FALSE}
knitr::opts_knit$set(verbose = TRUE)
knitr::opts_chunk$set(fig.align = "center", eval = FALSE)
options(scipen = 6, width = 85)
```

This is a vignette to brainstorm more flexible inputs for concatipede. No code is actually run, so we can just write the interface we'd like to have and experiment, and once we settle on something we can go to the coding phase!

## Preparing the template

If we want to give the user a bit more control and flexiblity over the collection of fasta file names, instead of just using the files in the current working directory, we could separate the **filename collection** step and the **template preparation** step. For example:

```{r }
# Collect the filenames
ff <- find_fasta(dir = "path/to/fasta-files/")

# Prepare the template
tpl <- concatipede_prepare(ff)

# Save the template
write_xl(tpl)
```

We could put this easily into a pipeline:

```{r }
fasta_dir <- "path/to/fasta-files/"

find_fasta(dir = fasta_dir) %>%
  concatipede_prepare() %>%
  write_xl("my-template.xslx")
```

`concatipede_prepare()` would be modified to accept a vector of file paths. The `find_fasta()` function would provide the "automatic detection" feature (taken out from `concatipede_prepare()`). The user could provide their own vector of file paths:

```{r }
fasta_files <- c("project-COI/file1.fa", "project/16S/file-32.fa")

concatipede_prepare(fasta_files) %>%
  write_xl("my_template.xslx")
```

We could also adapt the matching code so that someone could write something like:

```{r }
concatipede_prepare(fasta_files) %>%
  auto_match_seqs() %>%
  write_xl("my_template.xslx")
```

Basically, the idea would be to have one nice function for each distinct step (`concatipede_prepare`, `auto_match_seqs`, `write_xl`) and allow the user to combine them as they see fit.

## Merging the sequences

Once the user has checked and adjusted the template in Excel or another spreadsheet software, the merging could be done with:

```{r }
read_xl("my_final_template.xlsx") %>%
  concatipede() %>%
  write_faste("merged-seqs.fasta")
```

Here `concatipede()` would just do the merging and return an alignment (for example using the **ape** package formats). This would allow for things like:

```{r }
read_xl("my_final_template.xlsx") %>%
  concatipede() %>%
  plot_align() %>%
  write_faste("merged-seqs.fasta")
```

Of course, it would still be possible to keep a `out` argument to `concatipede()` to simply write:

```{r }
read_xl("my_final_template.xlsx") %>%
  concatipede(out = "merged-seqs.fasta") %>%
```

If we follow the pipe `%>%` philosophy as suggested above, it means that in the simpler cases, or if the user has been very careful about the sequence naming, something like this could be written:

```{r }
# Probably not used very often, but given flexible functions the only limit is
# the user's ideas!
find_fasta(dir = fasta_dir) %>%
  concatipede_prepare() %>%
  auto_match_seqs() %>%
  concatipede() %>%
  plot_align() %>%
  write_fasta("merged-seqs.fasta")
```

`write_xl()` could return its input invisibly, so that we could use it to save Excel tables as checkpoints:

```{r }
find_fasta(dir = fasta_dir) %>%
  concatipede_prepare() %>%
  write_xl("template.xslx") %>%
  auto_match_seqs() %>%
  write_xl("template_automatched.xlsx") %>%
  concatipede() %>%
  plot_align() %>%
  write_fasta("merged-seqs.fasta")
```

What about storing the directory information? What are the functions that need a directory information?

- `find_fasta()` needs a directory, and returns full path information.
- `concatipede_prepare()` needs full path information (or at least a directory), and saves a file or returns a tibble with basenames only. Directory information is lost. It could stored as an attribute to the tibble (but it would still be lost from the written file).
- `auto_match_seqs()` needs a tibble or an Excel file as an input.
- `concatipede()` needs a directory information. If provided a tibble without a directory attribute, then the directory should be passed as an argument. If it loads the table from a file, then the directory should also be provided by the user. When directory information is missing, the function could assume that the current working directory should be used (but it should also issue a warning about that so that it is not silent, and there could be an option `use_current = TRUE` to remove the warning).

## Testing the proposed functions

```{r echo = FALSE, eval = TRUE}
knitr::opts_chunk$set(fig.align = "center", eval =TRUE)
```

```{r message = FALSE}
library(concatipede)
```

Let's use the example fasta files shipped with the package. The code chunks below go through the whole pipeline step-by-step:

```{r }
# Get the target folder containing the fasta files
fasta_dir <- system.file("extdata", package = "concatipede")
fasta_dir
# Detect the fasta files
fasta_files <- find_fasta(dir = fasta_dir)
fasta_files
# Prepare the template and save it as an xlsx file
concatipede_prepare(fasta_files = fasta_files, out = "my-template")
```

At this stage, the template file could be modified by hand and provided as an input to `concatipede()`. Here, I will just load it again and use the automatic matching feature, without any manual correction (but this is just out of laziness for this example).

```{r }
# Load the template (unmodified from concatipede_prepare(), but in a real-life
# example it would be adjusted using Excel outside of R)
template <- read_xl("my-template.xlsx")
template
# Let's be lazy and use the auto-match
matched <- auto_match_seqs(template)
# Concatenate the sequences and save them as fasta
concatipede(matched, dir = fasta_dir, out = "merged-seqs", format = "fasta")
```

All of this can also run in a single pipeline:
```{r }
merged <- fasta_dir %>%
  find_fasta() %>%
  concatipede_prepare() %>%
  write_xl("template-for-later-check.xlsx") %>%
  auto_match_seqs() %>%
  write_xl("auto-matched-for-later-check.xlsx") %>%
  concatipede() %>%
  write_fasta("my-merged-seqs") %>%
  write_nexus("my-merged-seqs")
```

At this stage, `merged` contains the merged alignment in the R session:
```{r }
merged
```
but during the pipeline the alignment was also saved as a fasta file and as a nexus file, and two Excel files were saved for some manual checks after the pipeline has completed.

Note that this one-block pipeline only makes sense if the sequence names are good enough to allow the auto-match feature to do a perfect job. A more realistic pipeline is probably one with those two separate blocks:

```{r eval = FALSE}
# Prepare the xlsx template
fasta_dir %>%
  find_fasta() %>%
  concatipede_prepare() %>%
  auto_match_seqs() %>%
  write_xl("auto-match-to-manually-fix.xlsx")

# Then a manual step to check and fix the xlsx template outside of R

# Concatenate the sequences
read_xl("auto-match-manually-fixed.xlsx") %>%
  concatipede(dir = fasta_dir) %>%
  write_fasta()
```

Note that since the `fasta_dir` information is lost from the table when going out of R in Excel (to fix the sequence name matching), we have to specify the directory again in `concatipede()`. If we don't specify it, and the input table doesn't have the special attribute `dir_name` written by the `find_fasta()` function, then `concatipede()` will try to find the fasta files in the current directory by default.

Finally, the basic building blocks of the pipeline can be combined to create some ready-made functions for the users, for example:

```{r }
concatipede_auto_prepare <- function(fasta_dir, out) {
  fasta_dir %>%
    find_fasta() %>%
    concatipede_prepare() %>%
    auto_match_seqs() %>%
    write_xl(path = out)
}
```
